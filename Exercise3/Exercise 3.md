# Exercise 3: Hey, it's an app!
#### In this exercise we will put the final touches on our GUI.

## File Input/Output
A very common task in application development is providing the user the means interact with their local file directory.  This could be the ability to browse for local files (input) as well as specify (output) locations for saving files that have been modified or generated by the application.

Based on the previous exercises the Tkinter syntax should be starting to look famiiiar. Below we'll examine the widgets that work together to create our file I/O GUI.

**Label** - let's tell the user what they're looking at
```python
input_label = Label(self.master)
input_label['text'] = 'Input File'
input_label.grid(row=0, column=0)
```

**Entry** - nothing new here...
```python
self.input_entry_box = input_entry_box = Entry(self.master)
input_entry_box['width'] = 50
input_entry_box.grid(row=0,column=1)
 ```

**Button** - finally something I can click!
```python
input_button = Button(self.master)
input_button['text'] = 'BROWSE'
input_button['command'] = self.open_file
input_button.grid(row=0, column=2)
```

These three components form our simple UI.
Notice the `command` attribute on the button. Well, the following method ties it all together:
```python
def open_file(self):

  # Define file dialog options
  options = {}
  options['defaultextension'] = '.csv'
  options['filetypes'] = [('comma seperated value', '.csv')]
  options['title'] = 'Input csv file:'

  # Open file dialog
  file_path = tkFileDialog.askopenfile(**options)

  # Check to make sure a file was specified
  if file_path:

  # Insert file path into entry box
  self.input_entry_box.insert(0, file_path.name)
```
The method utilizes *tkFileDialog* (a separate import) ([reference](http://tkinter.unpythonic.net/wiki/tkFileDialog)) to open the native system's file directory.  If a file is selected the entry box is updated with the file path.
This is a good example of how to link in hooks to specific user actions (in this case selecting a file input). Ultimately, these hooks (or events) are what drives your app behind the scenes. As you'll see in later exercises these hooks will be used to not only execute the app's functionality, but also ensure that the user has provided the necessary information to do so.


## Full code for App class:
Below is the full code for the basic Tkinter class for creating an interface with file I/O.
```python
from Tkinter import *
import tkFileDialog
from ProcessData import DataProcessor


class App():

    '''
    This is a basic Tkinter app
    '''

    # class-level attributesrr

    master = Tk() # Create Tk instance

    def __init__(self):

        # Assign additional class-level attributes

        # Execute core methods
        self.config_app()
        self.config_widgets()
        self.run_app()

    def config_app(self):

        # Configure app
        self.master.title('SAMPLE')

    def config_widgets(self):

        # Insert widgets

        input_label = Label(self.master)
        input_label['text'] = 'Input File'
        input_label.grid(row=0, column=0)

        self.input_entry_box = input_entry_box = Entry(self.master)
        input_entry_box['width'] = 50
        input_entry_box.grid(row=0,column=1)

        input_button = Button(self.master)
        input_button['text'] = 'BROWSE'
        input_button['command'] = self.open_file
        input_button.grid(row=0, column=2)

        output_label = Label(self.master)
        output_label['text'] = 'Output File'
        output_label.grid(row=1, column=0)

        self.output_entry_box = output_entry_box = Entry(self.master)
        output_entry_box['width'] = 50
        output_entry_box.grid(row=1,column=1)

        output_button = Button(self.master)
        output_button['text'] = 'BROWSE'
        output_button['command'] = self.save_file
        output_button.grid(row=1, column=2)

        exec_button = Button(self.master)
        exec_button['text'] = 'EXECUTE'
        exec_button['command'] = self.gis_process
        exec_button.grid(row=2,column=1)

    def run_app(self):

        # Run the mainloop
        self.master.mainloop()

    def open_file(self):

        # Define file dialog options
        options = {}
        options['defaultextension'] = '.csv'
        options['filetypes'] = [('comma seperated value', '.csv')]
        options['title'] = 'Input csv file:'

        # Open file dialog
        file_path = tkFileDialog.askopenfile(**options)

        # Check to make sure a file was specified
        if file_path:

            # Insert file path into entry box
            self.input_entry_box.insert(0, file_path.name)


    def save_file(self):

        # Define file dialog options
        options = {}
        options['defaultextension'] = '.shp'
        options['filetypes'] = [('shapefile', '.shp')]
        options['title'] = 'Save output as:'

        # Open file dialog
        file_path = tkFileDialog.asksaveasfile(**options)

        # Check to make sure a file was specified
        if file_path:

            # Insert file path into entry box
            self.output_entry_box.insert(0, file_path.name)

    def gis_process(self):

        # Retrieve input parameters
        input_file_path = self.input_entry_box.get()
        output_file_path = self.output_entry_box.get()

        # Process data
        data_processor = DataProcessor(input_file_path, output_file_path)
        data_processor.create_shapefile()

newApp = App()

```
At this point the app is pretty elementary; it takes a CSV file as input and a shapefile path as the output (the code to perform this conversion is in its own separate class, of course).
If you're looking to add more features to your app (more gizmos to your swiss army knife) then see below for bonus material.
![swiss is best](https://www.rei.com/media/product/403141)


## Bonus!
There are lots of resources out there describing the 17+ Tkinter widgets available out-of-the-box.
We found [this reference](http://effbot.org/tkinterbook/tkinter-index.htm#class-reference) to be one of the easiest to work with.
We've also included the 170-page compendium on Tkinter from New Mexico Tech if you really want to go to town.

In the context of this application (and as you'll see later), some sensical extensions could include:
  * list boxes for listing out potential fields for statistical summaries
  * additional file inputs for implementing a summary by location with a supporting polygon dataset
  * message boxes for providing adding user feedback
  * progress bars for the above reason



