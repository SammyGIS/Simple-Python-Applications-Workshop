# Exercise 3: Hey, it's an app!
#### In this exercise we will put the final touches on our GUI.

## File Input/Output
A very common task in application development is providing the user the means interact with their local file directory.  This could be the ability to browse for local files (input) as well as specify (output) locations for saving files that have been modified or generated by the application.

Based on the previous exercises the Tkinter syntax should be starting to look famiiiar. Below we'll examine the widgets that work together to create our file I/O GUI.

**Label** - let's tell the user what they're looking at
```python
input_label = Label(self.master)
input_label['text'] = 'Input File'
input_label.grid(row=0, column=0)
```

**Entry** - nothing new here...
```python
self.input_entry_box = input_entry_box = Entry(self.master)
input_entry_box['width'] = 50
input_entry_box.grid(row=0,column=1)
 ```

**Button** - finally something I can click!
```python
input_button = Button(self.master)
input_button['text'] = 'BROWSE'
input_button['command'] = self.open_file
input_button.grid(row=0, column=2)
```

These three components form our simple UI.
Notice the `command` attribute on the button. Well, the following method ties it all together
```python
def open_file(self):

  # Define file dialog options
  options = {}
  options['defaultextension'] = '.csv'
  options['filetypes'] = [('comma seperated value', '.csv')]
  options['title'] = 'Input csv file:'

  # Open file dialog
  file_path = tkFileDialog.askopenfile(**options)

  # Check to make sure a file was specified
  if file_path:

  # Insert file path into entry box
  self.input_entry_box.insert(0, file_path.name)
```
The method utilizes *tkFileDialog* (a separate import) ([reference](http://tkinter.unpythonic.net/wiki/tkFileDialog)) to open the native system's file directory.  If a file is selected the entry box is updated with the file path.
This is a good example of how to link in hooks to specific user actions (in this case selecting a file input). Ultimately, these hooks (or events) are what drives your app behind the scenes. As you'll see in later exercises these hooks will be used to not only execute the app's functionality, but also ensure that the user has provided the necessary information to do so.


## Full code for App class:
```python
from Tkinter import *
import tkFileDialog
from ProcessData import DataProcessor


class App():

    '''
    This is a basic Tkinter app
    '''

    # class-level attributesrr

    master = Tk() # Create Tk instance

    def __init__(self):

        # Assign additional class-level attributes

        # Execute core methods
        self.config_app()
        self.config_widgets()
        self.run_app()

    def config_app(self):

        # Configure app
        self.master.title('SAMPLE')

    def config_widgets(self):

        # Insert widgets

        input_label = Label(self.master)
        input_label['text'] = 'Input File'
        input_label.grid(row=0, column=0)

        self.input_entry_box = input_entry_box = Entry(self.master)
        input_entry_box['width'] = 50
        input_entry_box.grid(row=0,column=1)

        input_button = Button(self.master)
        input_button['text'] = 'BROWSE'
        input_button['command'] = self.open_file
        input_button.grid(row=0, column=2)

        output_label = Label(self.master)
        output_label['text'] = 'Output File'
        output_label.grid(row=1, column=0)

        self.output_entry_box = output_entry_box = Entry(self.master)
        output_entry_box['width'] = 50
        output_entry_box.grid(row=1,column=1)

        output_button = Button(self.master)
        output_button['text'] = 'BROWSE'
        output_button['command'] = self.save_file
        output_button.grid(row=1, column=2)

        exec_button = Button(self.master)
        exec_button['text'] = 'EXECUTE'
        exec_button['command'] = self.gis_process
        exec_button.grid(row=2,column=1)

    def run_app(self):

        # Run the mainloop
        self.master.mainloop()

    def open_file(self):

        # Define file dialog options
        options = {}
        options['defaultextension'] = '.csv'
        options['filetypes'] = [('comma seperated value', '.csv')]
        options['title'] = 'Input csv file:'

        # Open file dialog
        file_path = tkFileDialog.askopenfile(**options)

        # Check to make sure a file was specified
        if file_path:

            # Insert file path into entry box
            self.input_entry_box.insert(0, file_path.name)


    def save_file(self):

        # Define file dialog options
        options = {}
        options['defaultextension'] = '.shp'
        options['filetypes'] = [('shapefile', '.shp')]
        options['title'] = 'Save output as:'

        # Open file dialog
        file_path = tkFileDialog.asksaveasfile(**options)

        # Check to make sure a file was specified
        if file_path:

            # Insert file path into entry box
            self.output_entry_box.insert(0, file_path.name)

    def gis_process(self):

        # Retrieve input parameters
        input_file_path = self.input_entry_box.get()
        output_file_path = self.output_entry_box.get()

        # Process data
        data_processor = DataProcessor(input_file_path, output_file_path)
        data_processor.create_shapefile()

newApp = App()

```
## General Workflow:
The general workflow remains the same:
1. Import **all** from Tkinter.
2. Define the class name as **App**.
3. Create Tk **root** window widget as a class-level attribute.
4. In the **init** method, we run the core methods
    - configure app
    - configure widgets
    - run app

#### Take the code from Exercise 1 and slot it into the appropriate places in the above skeleton code template.
#### Running the code again, it should create the same app, now just a bit more classy behind the scenes.

